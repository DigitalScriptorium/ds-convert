#!/usr/bin/env ruby

require 'thor'
require 'csv'
require_relative '../lib/ds/cli'

# TODO: No URIs for Scribes in prototype data set; need test data

class DSConvertCLI < DS::CLI
  DS.configure!

  def self.exit_on_failure?
    true
  end

  class_option :'output-csv', banner: 'FILE', desc: "Name of the output CSV file [default: output.csv]", default: 'output.csv', aliases: '-o'

  desc "marc XML [XML...]", "Convert MARC XML to DS CSV"
  long_desc <<-LONGDESC
    Convert MARC XML to DS CSV
  LONGDESC
  option :institution, banner: 'INSTITUTION', desc: "Short name of the institution to create this CSV for; REQUIRED", aliases: '-i'
  option :'holdings-file', banner: 'FILE', desc: 'Associated Holdings File (if separate from records)', aliases: '-f'
  def marc *files
    return false unless validate_args files
    Recon::ReconData.update! unless skip_git? options

    inst_qid = DS::Institutions.find_qid options[:institution]
    abort "Not a known institution: #{options[:institution]}" unless inst_qid
    preferred_name = DS::Institutions.preferred_name options[:institution]
    holdings_file = File.open(options[:'holdings-file']) { |f| Nokogiri::XML(f) } unless options[:'holdings-file'].nil?
    timestamp = DS.timestamp

    rows = select_input(files).flat_map { |in_xml|
      source_file = in_xml.chomp # remove newline in case input if from ARGF
      xml = File.open(source_file) { |f| Nokogiri::XML(f) }
      xml.remove_namespaces!

      records = xml.xpath '//record'

      records.map { |record|
        mapper = DS::Mapper::MarcMapper.new(
          record: record, inst_qid: inst_qid, inst_code: options[:inst], preferred_name: preferred_name,
          holdings_file: holdings_file, timestamp: timestamp,
          source_file: source_file)
        mapper.map_record
      }
    }
    validate! rows unless options[:'skip-validation']
    write_csv rows, options
  end

  desc "mets XML [XML...]", "Convert DS 1.0 METS XML to DS CSV"
  long_desc <<-LONGDESC
    Convert DS 1.0 METS XML to DS CSV
  LONGDESC
  def mets *files
    return false unless validate_args files
    Recon::ReconData.update! unless skip_git? options
    timestamp = DS.timestamp

    iiif_lookup = Recon::URLLookup.new 'iiif_manifests'
    ia_url_lookup = Recon::URLLookup.new 'legacy_ia_urls'
    rows = select_input(files).map { |in_xml|
      source_file = in_xml.chomp # remove newline in case input if from ARGF
      xml = File.open(source_file) { |f| Nokogiri::XML(f) }
      mapper = DS::Mapper::DSMetsMapper.new(
        record: xml, timestamp: timestamp, iiif_lookup: iiif_lookup,
        ia_url_lookup: ia_url_lookup, source_file: source_file
      )
      mapper.map_record
    }

    validate! rows unless options[:'skip-validation']
    write_csv rows, options
  end

  desc "openn XML [XML...]", "Convert OPenn TEI XML to DS CSV"
  long_desc <<-LONGDESC
    Convert OPenn TEI XML to DS CSV
  LONGDESC
  def openn *files
    return false unless validate_args files
    Recon::ReconData.update! unless skip_git? options

    timestamp = DS.timestamp
    rows = select_input(files).map { |in_xml|
      source_file = in_xml.chomp # remove newline in case input if from ARGF
      record = File.open(source_file) { |f| Nokogiri::XML(f) }
      record.remove_namespaces!
      mapper = DS::Mapper::OPennTEIMapper.new record: record, timestamp: timestamp, source_file: source_file
      mapper.map_record
    }
    validate! rows unless options[:'skip-validation']
    write_csv rows, options
  end

  protected

  def write_csv rows, options
    out_csv = options[:'output-csv']
    CSV.open out_csv, "w", headers: true do |csv|
      csv << DS::HEADINGS
      rows.each do |row|
        csv << row
      end
    end
    puts "Wrote: '#{out_csv}'"
  end

  def validate_args files
    return true if read_from_stdin? files

    cannot_find = files.reject { |f| File.exist?(f) }
    return true if cannot_find.empty?

    puts "Can't find input file(s): #{cannot_find.join '; ' }"
    false
  end
end

DSConvertCLI.start ARGV